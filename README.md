# Sails-API with Passport and JWT Authentication

This tutorial has been set up for the purpose of demonstrating how to set up a simple API with Authentication. For the purpose of this tutorial, it will be assumed that there is no front end application directly attached to this Repository. Instead all API requests will be done from other applications using JWT for authentication.

After creating various API's for various applications, each time I have been forced to apply authentication a little differently with different work arounds. Slowly I began to figure out a more standard way of applying Authentication using the power of SailsJs. In this tutorial we will start completely from scratch allowing us to create a strong and clean baseline for any API requiring Authentication.

## 1. Initial Setup

1. First we will need to set up the initial Sails Application. Fortunately Sails makes this very simple by running the following command:
 - `sudo npm -g install sails` -- if you do not have SailsJs installed yet
 - `sails new Sails-API` -- Feel free to name your project what ever you wish.

2. Generate our Auth Models, Controllers, Policies, and Services.
Once again Sails along with Sails-Generate-Auth, will make this very simple
 - `npm install sails-generate-auth` -- Install the Generator
 - `sails generate auth`
 - Let's not forget to install the following dependencies
    - `npm install passport --save`
    - `npm install bcryptjs --save`
    - `npm install validator --save`
    - `npm install passport-local --save`
3. Uncomment all Passport Strategies except for local in `config/passport.js`.
```
local: {
    strategy: require('passport-local').Strategy
  },
```

The following items were generated by the Auth Generator. We will be modifying a few of the following files in later steps.

```
api
  - controllers
        - AuthController
  - models
        - Passport.js
        - User.js
  - policies
        - bearerAuth.js
        - passport.js
        - sessionAuth.js
  - services
        - passport.js
        - protocals
             - bearer.js
             - cas.js
             - index.js
             - oauth.js
             - oauth2.js
             - openid.js
config
  - passport.js
views (Will not be used)
  - auth
        - login.ejs
        - register.ejs
```


At this point our we have the basic structure for authentication but we still do not have a functional application. We will be customizing quite a bit in the next few steps. Here are a few items to keep in mind:

- A User and Passport model was generated. All user passwords will be stored in the Passport model and will be tied to a specific user.
- At this point no database has been set up for storing any of our models. In this tutorial we will be using MongoDb but SailsJs has built in functionality to use MySQL and PostgreSQL.
- We will set up routes to handle Registration and Login using the newly created auth controller
- For now we will be setting up Passport Local only.
- We will not be using sessionAuth for this API as we have no front end views that we will be implementing

## 2. Load Passport, Setup Routes and Policies
- We must Load Passport into our Sails App. To do this, add the following line of code to `config/bootstrap.js`
```
sails.services.passport.loadStrategies();
```
- We will be using PassportLocal and no views therefore we will only add the following routes into our `config/routes.js` file.
```
'post /auth/local': 'AuthController.callback',
'post /auth/local/:action': 'AuthController.callback',
```
- Comment out or remove the existing route which was set up by Sails
```
'/': {
   view: 'homepage'
 }
```
- In `config/policies.js` add the following lines of code
```
'*': ['passport'],
'auth': {
  '*': ['passport']
}
```
- 'config/policies.js' will be the main place where we will be able to restrict access and require authentication to specific controllers
- As shown above, all paths require `passport` before continueing to the specified controller. At this point, this merely just initialized passport but does not restrict any access.
## 3. Setup Database
Sails comes built in with Waterline as the ORM which will work with MongoDb, MySQL and PostgreSQL. We will be using MongoDb. I will not go over mongo setup. I use Robomongo to manage Mongo Databases.
- In `config/connections.js` uncomment the following lines
```
  // someMongodbServer: {
  //   adapter: 'sails-mongo',
  //   host: 'localhost',
  //   port: 27017,
  //   user: 'username', //optional
  //   password: 'password', //optional
  //   database: 'your_mongo_db_name_here' //optional
  // },
```
- Change the server name as you wish and modify to look like below:
```
  SailsApiServer: {
    adapter: 'sails-mongo',
    host: 'localhost',
    port: 27017,
    database: 'SailsApiServer',
    //user: 'username', //optional
    //password: 'password', //optional
    //database: 'your_mongo_db_name_here' //optional
  },
```
- In `config/models.js` add the following line (Replace connection with the name you used for your connection above)
```
  connection: 'SailsApiServer',
  migrate: 'alter'
```
- Since we are using 'sails-mongo' as our adapter we need to install the package
`npm install sails-mongo --save`

### 4. Modify AuthController and Test
Now that we have set up the basics, we need to modify the AuthController. The AuthController was created by the generator and is setup for the purpose of registering and logging in through a form and storing authentication into a session cookie. We are not interested for session authentication therefore we will replace what is inside the Auth Controller with the following code:
```
AuthController = {
  callback: function (req, res) {
    passport.callback(req, res, function (err, user, challenges, statuses) {
      var message = req.flash();
      if (err || !user) {
        return res.json({authenticated: false, user: user, message: message});
      }

      req.login(user, function (err) {
        if (err) {
          return res.json({authenticated: false, user: user, message: message});
        }

        res.json({authenticated: true, user: user, message: message});
      });
    });
  },

};

module.exports = AuthController;
```

As you can see, we are still using the generated `passport.js` service for authenticating our user but now we will be returning a json object which includes an whether the user is authenticate, the User object itself and an error message if one exists.

Now that we have modified our response to send back a json object, we can begin testing. I will be using Postman for testing the API.

### Register a User
In Postman do a Post request to:
`http://localhost:1337/auth/local/register`

In the body using `x-www-form-urlencoded` add the following key value pairs
```
email : somebody@gmail.com
username : somebody
password : password
```
Feel free to test out different email, username and password and test out the various errors that you might get back.

### Login a User
In Postman do a Post request to:
`http://localhost:1337/auth/local`

In the body using `x-www-form-urlencoded` add the following key value pairs
```
identifier : somebody
password : password
```
Notice how we used `identifier`. This allows us to login the user using either an Email or Password.


## 5. JWT Issuing
At this point we can register and login, but logging in merely just tells us whether a username and password are in the database. This really does nothing at this point in time. We must now add a method of returning a Jason Web Token in the JSON object if a user is authenticated.

1. Add a file called `jwToken.js` under `api/services` with the following code:
  ```
  var
    jwt = require('jsonwebtoken'),
    tokenSecret = "superdupercrazysecrete";

  // Generates a token from supplied payload
  module.exports.issue = function(payload) {
    return jwt.sign(
      payload,
      tokenSecret, // Token Secret that we sign it with
      {
        expiresIn : 180 // Token Expire time
      }
    );
  };

  // Verifies token on a request
  module.exports.verify = function(token, callback) {
    return jwt.verify(
      token, // The token to be verified
      tokenSecret, // Same token we used to sign
      {},
      callback //Pass errors or decoded token to callback
    );
  };
  ```
2. Modify the Auth controller to return a JWT using the service that we just created with the `user` as the payload
  ```
  AuthController = {
    callback: function (req, res) {
      passport.callback(req, res, function (err, user, challenges, statuses) {
        var message = req.flash();
        if (err || !user) {
          return res.json({authenticated: false, user: user, message: message});
        }

        req.login(user, function (err) {
          if (err) {
            return res.json({authenticated: false, user: user, message: message});
          }

          res.json({authenticated: true, message: message, token: jwToken.issue({user: user})});
        });
      });
    },

  };

  module.exports = AuthController;
  ```

## 6. JWT Authentication
Now that we receive a Jason Web Token when registering and logging in a User, we can use that JWT in an Authorization Header to access other controllers.

1. First let's add a Policy Middleware. In the `api/policies` folder add a new file called `isAuthorized.js` and add the following code
  ```
  module.exports = function (req, res, next) {
    var token;

    if (req.headers && req.headers.authorization) {
      var parts = req.headers.authorization.split(' ');
      if (parts.length == 2) {
        var scheme = parts[0],
          credentials = parts[1];

        if (/^Bearer$/i.test(scheme)) {
          token = credentials;
        }
      } else {
        return res.json(401, {err: 'Format is Authorization: Bearer [token]'});
      }
    } else if (req.param('token')) {
      token = req.param('token');
      // We delete the token from param to not mess with blueprints
      delete req.query.token;
    } else {
      return res.json(401, {err: 'No Authorization header was found'});
    }

    jwToken.verify(token, function (err, decoded) {
      if (err) return res.json(401, {err: 'Invalid Token!'});
      req.user = decoded; // This is the decrypted token or the payload you provided
      next();
    });
  };
  ```
  Notice how we can either add a header as `Authorization: Bearer [token]` or we can add a parameter called `token` with the token

2. Now let's go back to `config/policies.js` and modify the first policy:
  ```
  '*': ['isAuthorized'],
  ```
  This will make sure that all routes and controllers pass through the `isAuthorized` policy before continuing. The auth actions should not pass through this policy but instead through the `passport` policy in order to create and login a user based on credentials. For this reason we have already set the following in this same file
  ```
  'auth': {
      '*': ['passport']
    }
  ```
3. To test our new policy lets create a new controller called `TestController.js` under `api/TestController.js` with the following code
  ```
   module.exports = {
     getUser: function (req, res) {
       return res.json(req.user);
     }
   };

  ```
  This will return the decoded token. You may wonder how `req.user` seems to "magically" have the decoded token. Well if you notice in `isAuthorized.js` policy, once a token is verified and decoded, it is stored into `req.user` for us to use in any controller.

  - To test in Postman, first login with credentials of a user
  ```
  identifier: somebody
  password: password
  ```
  - This will return a token that we will copy
  - Then we will do a get request to `http://localhost:1337/test/getUser` with an Authorization Header:
  ```
  Authorization: Bear [token]
  Example:
  Authorization: Bear eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7InVzZXJuYW1lIjoic29tZWJvZHkiLCJlbWFpbCI6ImFzZGZhc0BnYW1zZGYuY29tIiwiY3JlYXRlZEF0IjoiMjAxNi0xMi0xOVQwODoxMDo0OS4wMzNaIiwidXBkYXRlZEF0IjoiMjAxNi0xMi0xOVQwODoxMDo0OS4wMzNaIiwiaWQiOiI1ODU3OTYwOWNlY2YzZjQ3NTMzMjJiYWMifSwiaWF0IjoxNDgyMTM1MDQ5LCJleHAiOjE0ODIxMzUyMjl9.LZRd8rnoMsaIUpgFia78uF1ZwWbXJBjJhyi_D2inxyE
  ```
  You should receive the following json response:
  ```
  {
    "user": {
      "username": "somebody",
      "email": "somebody@gmail.com",
      "createdAt": "2016-12-19T08:10:49.033Z",
      "updatedAt": "2016-12-19T08:10:49.033Z",
      "id": "58579609cecf3f4753322bac"
    },
    "iat": 1482135049,
    "exp": 1482135229
  }
  ```
  Remember that if you restart the server then you must re-login and receive a new token.

## 6. Customizing Policies
Now we have set up registration, login, and we have required JWT authentication for all routes except for auth routes. Let look into other possiblilities.
### Allow access to a specific controller without Authentication
1. Let's start by creating a new action in our test controller called `unauthenticated`
  ```
  unAuthenticated: function (req, res) {
      return res.send("This controller action does not require authentication")
   }
  ```
2. Then let's allow access to this action. Add the following policy to `config/policy.js`
  ```
  'TestController': {
      'unauthenticated': true
    }
  ```
3. Test this controller with out adding the `Authentication` header. 

NOTE: We have not added any routes pointing to our TestController Actions. In SailsJs, action are auto-routed using the Blueprint API which come built into Sails. For development this feature is great for quickly testing functions but for production we would want to disable this and manually control how actions are routed.
